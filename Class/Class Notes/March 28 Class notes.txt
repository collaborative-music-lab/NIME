Working with continuous and discrete data
March 28 2022

discrete vs continuous data

Discrete data:
* avoiding double triggers
	- dead time
	- pattern matching
		https://hackaday.com/2015/12/09/embed-with-elliot-debounce-your-noisy-buttons-part-i/

0 0 0 0 0 0 0 0 0 0 00 0 1 0 01 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 10 1 1 0 01 01  01 0 0 0 0 0 0 0 0 
	- effect on detecting rapid changes
* on and off states
	- toggle and momentary
	- memory
* challenges with inconsistent communication
* converting to continuous data
* pitch

Continuous data
* data rates / jitter / dropped data / stairstepping
* converting to discrete events
	- thresholds, dead time, schmitt triggers
* smoothing
	- running calculations, buffers, sample history
	- mean, median, filters

avg:
	buffer[index] = newVal
	index++
	buffer.sum / bufferSize

avg:
	sum *= 0.9
	sum = sum + newVal

	- fixed length buffer
		- keep track of sample order
		- or simply subtract average value
	- one-pole filter
		out = alpha*prev + (1-alpha)*new
		0 < alpha < 1.0
		alpha typically between 0.5 and 0.999....
	- challenges:
		- responding to changes quickly
		- calculation efficiency
		- implementation efficiency
		- c.f. one-euro filter
		http://cristal.univ-lille.fr/~casiez/1euro/
* looking for change / delta
	- delta = new-prev
	- also called the derivative
	- insensitive to static offsets
	- generally combined with smoothing...
	- often absolute value of change is useful, for example for accumulation...

Accumulation
* keeps track of progress of data compared to a reference
* also called integration
* c.f. mouse position on screen or trumpet
* useful metaphor for physical interaction
* implementations:
	* pure integration: chording keyboards
	- mother of all demos - check it out!
	* leaky integration:
		- add each new sample to a bucket
		- for each new sample subtract some value (either fixed leak or fraction of stored value)

leakyIntegrator:
	sum *= 0.9 #attenuate the sum
	# sum -= fixedVal
	# if sum < 0: sum = 0
	sum = sum + newVal

Combining sensor inputs
* position tracking using multiple sensors...

Case study: capacitive sensing